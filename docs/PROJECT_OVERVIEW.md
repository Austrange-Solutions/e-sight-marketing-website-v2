# Project Overview — E-Sight Marketing Website V2 (MACEAZY / E-Kaathi Pro)

This document summarizes architecture, core flows, important files, and operational rules for the E-Sight marketing website repository. It consolidates project knowledge from repository markdowns and implementation notes.

## Purpose
- E-commerce platform for products (catalog, cart, checkout, orders)
- Donation portal with multi-foundation support and configurable fee splitting

## Tech stack
- Next.js 15 (App Router)
- Bun runtime (development with Turbopack)
- TypeScript (strict)
- MongoDB + Mongoose (with connection caching)
- Razorpay for payments
- AWS S3 for uploads + CloudFront for delivery

## High-level architecture
- Frontend: Next.js App Router pages and React components (under `src/app` and `src/components`).
- Backend: Next.js server routes in `src/app/api/**` handle data access, Razorpay order creation/verification, and admin-only actions.
- Database: MongoDB accessed via Mongoose models in `src/models` with a cached connection helper in `dbConfig`.
- Storage: S3 uploads are performed by clients using pre-signed URLs generated by server endpoints; images are served via CloudFront.

## Donation system (core rules)
1. Two-tier fee calculation:
   - Step 1: Platform fee = donationAmount * platformFeePercent
   - Step 2: Remaining = donationAmount - platformFee; then
     - foundationAmount = remaining * foundationSharePercent
     - companyAmount = remaining - foundationAmount
2. Razorpay fees are NOT included in the breakdown. Razorpay gateway fees are absorbed by the platform.
3. Razorpay order amount equals the donation amount (no extra gateway fee charged to donor).
4. Donation breakdowns (platformFee, foundationAmount, companyAmount) are stored server-side and must NOT be returned to public clients; only visible in admin views.
5. Foundations are dynamic (admins can add). Preferred identifier is `code` (e.g., `vsf`, `cf`) — fallback to `_id` allowed. Never reintroduce legacy `general` foundation into active lists.

## Important files (where to look)
- Models
  - `src/models/foundationSettingsModel.ts` — foundation level config (codes, percentages)
  - `src/models/Donation.ts` — persisted donation (amount, platformFee, foundationAmount, companyAmount, razorpay ids)
  - `src/models/userModel.ts` — user data and admin flag
- API routes
  - `src/app/api/donate/create/route.ts` — computes breakdown + creates Razorpay order
  - `src/app/api/donate/verify/route.ts` — verifies Razorpay signature and persists Donation
  - `src/app/api/images/generate-presigned-url/route.ts` — S3 presigned URL generator (admin-only)
- Frontend
  - `src/components/donate/MultiFoundationDonateButtons.tsx` — Razorpay script loader and UI
  - `src/components/RazorpayButton.tsx` — product checkout integration (if present)
- Admin
  - `src/app/admin/dashboard/page.tsx` — admin dashboard shell
  - `src/components/admin/` — admin management tabs and components

## Auth and runtime rules
- User JWT token stored in cookie `token`. Use `getUserFromToken()` from `src/middleware/*` helpers where needed.
- Admin auth is separate. Admin token stored in cookie `admin-token` (2-hour expiry). Use `getAdminFromRequest()` in admin routes and deny access when absent.
- Routes that use server-side JWT verification or Node-only modules should set `export const runtime = 'nodejs'`.

## Database connection
- Always call `await connect()` (the project's connection helper) at the start of each API route. Connection caching is configured to avoid exhausting Atlas connections (recommended `maxPoolSize: 5`, `minPoolSize: 1`).

## AWS S3 & CloudFront
- Pre-signed uploads: two-step flow — server returns pre-signed URL, client uploads directly to S3.
- S3 prefixes used:
  - `donation-logos/` — foundation logos
  - `products/` — product images
- Always serve images via CloudFront domain: `${NEXT_PUBLIC_CLOUDFRONT_DOMAIN}/${key}`

## Environment variables (selected)
- `MONGODB_URI`
- `TOKEN_SECRET`, `NEXTAUTH_SECRET`
- `RAZORPAY_KEY_ID`, `RAZORPAY_KEY_SECRET`
- `AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, `AWS_REGION`, `S3_BUCKET_NAME`, `NEXT_PUBLIC_CLOUDFRONT_DOMAIN`
- `RESEND_API_KEY` (email/send)

## Operational gotchas & recommendations
- Currency math: do arithmetic in paise (integer) or apply a consistent rounding rule (prefer round-half-up to nearest paise). Ensure tests cover rounding.
- Idempotency: verify `razorpayPaymentId` uniqueness before persisting donation to avoid duplicates.
- Input validation: use Zod in API routes for input validation.
- Do not send breakdowns to the frontend. Expose only the Razorpay order id and minimal metadata.
- Exclude legacy `general` foundation in any lists or filters shown to users.

## Suggested next steps (low-risk, high-value)
1. Add this file to `docs/PROJECT_OVERVIEW.md` (done).
2. Add unit tests for donation breakdown calculation (happy path + rounding edge case).
3. Scan `src/app/api/**` to ensure `await connect()` is present in each route and prepare patches for missing ones.
4. Add tests or CI steps that run the unit tests (if CI exists).
5. Add a tiny script to validate required environment variables on startup.

## Contact points in code (quick jump list)
- Donation routes: `src/app/api/donate/create/route.ts`, `src/app/api/donate/verify/route.ts`
- Foundation config: `src/models/foundationSettingsModel.ts`
- Admin dashboard: `src/app/admin/dashboard/page.tsx` and `src/components/admin/` files

---
If you want, I can now implement step 2 (unit tests for donation breakdown) and step 3 (scan API routes for `connect()` and prepare fixes). Pick which to do next or let me run both.
